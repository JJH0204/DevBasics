# Data Structure and Algorithms
## 자료구조란?
***데이터를 효율적으로 저장하는 방식***

### 자료구조의 목적
1. **메모리 리소스 절약**
   - 한정된 메모리 공간을 효율적으로 사용
2. **프로그램 실행 시간 단축** (whit 알고리즘)
   - 효율적인 알고리즘을 위해 우선 효율적인 자료구조를 구현
3. **프로그램 구현 난이도 감소**
   - 프로그램 목적에 맞는 적절한 자료구조는 구현 시간을 줄여준다.

### 자료구조의 분류 (데이터 저장 형태에 따른)
1. **선형구조**: 여러 개의 자료를 한 줄로 순서대로 저장
   - 리스트
   - 스택
   - 큐
2. **비선형구조**: 
   - 트리
   - 히프
   - 그래프
3. 그 외: 단순 구조와 파일 구조
   - 단순 구조: 정수(int), 실수(float), 문자(char) 등 프로그램에서 기본으로 제공하는 자료형
   - 파일 구조: 메모리가 아닌 하드디스크에 저장되는 데이터(순차적, 상대적, 색인 파일, 다중 키 파일)

## 자료구조와 알고리즘
**알고리즘(algorithm)은 어떤 문제를 해결하기 위한 효율적인 절차**
효율적인 알고리즘 개발을 위해 자료구조는 필수, 효율적인 자료구조 개발을 위해 알고리즘 또한 필수

### 알고리즘이란?
**1부터 100까지 합을 구하시오.**
- 1부터 100까지 모든 정수의 합을 for문으로 구한다. -> 과연 효율적인가? -> 효율 분석이 필요하다.

### 알고리즘의 표현
| 종류          |                        내용                        |                                                                                                    특지점 |
| :------------ | :------------------------------------------------: | --------------------------------------------------------------------------------------------------------: |
| 자연어        |           사람이 사용하는 일반 언어표현            |                                                           기술하는 사람에 따라 일관성, 명료함이 달라진다. |
| 프로그램 언어 |            c 같은 프로그램 언어로 표현             |              알고리즘은 소스코드로 구현하기에 추가 구현이 필요없다. 문법에 맞게 작성해야 함 그래서 엄격함 |
| 순서도        |                  그림으로 도식화                   |                                            알고리즘 단계를 직관적으로 표현, 복잡한 알고리즘 표현에 부적합 |
| 의사 코드     | 특정 프로그램 언어가 아닌 가상(유사)의 언어로 표현 | 프로그램 언어보다 덜 엄격, 자연어 보다 체계적, 사람마다 표현이 다름, 가상 코드/유사 코드/슈도 코드라 불림 |
- 자연어는 사용하지 않는다.
- 간단한 알고리즘, 대략적인 흐름 확인용 -> 순서도
- 다소 복잡한 알고리즘 -> 의사 코드

### 순서도와 의사 코드
- 책 21p

### 알고리즘 성능 분석
- 가장 효율적인 알고리즘은 무엇인가?
  - 1부터 100까지 수를 모두 더하기 > 1+2+3+'''+99+100 > 100 번실행
  - (100*(1+100))/2 > 3번 실행 > 위 알고리즘보다 효율적
- 결론! **알고리즘의 성능은 결국 연산 횟수가 얼마만큼 적인가!**

#### 시간 복잡도
- 입력 값에 따라 알고리즘의 수행에 걸리는 시간(수행되는 연산 횟수)
  - 1부터 100까지 > 1부터 N까지 > 수행되는 연산 빈도를 확인할 수 있다.
  - 1부터 100까지 수를 모두 더하기 = 3n+2번 > n 값이 증가하면 더 오래걸림
  - (n*(1+n))/2 = 4번 > n 값과 상관없이 4번만 실행됨

#### 빅-오(big O) 표기법
- 알고리즘의 시간 복잡도는 시간 복잡도 함수 중에 가장 큰 영향을 주는 n에 대한 항만 표시
- 이 경우 n 항에 붙는 계수는 1로 보아서 생략
  - O(3n+2), n에 대한 항 -> O(3n), 3생략 -> O(n) "Big O of n"
  - O(4) -> O(1)
  > 두 개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n >= n0에 대해 | f(n) | <= c |g(n)| 을 만족하는 2개의 상수 c 와 na가 존재하면 f(n) = O(g(n))입니다.


- 시간 복잡도 최고차항들
   | big-O      |      명칭 |
   | :--------- | --------: |
   | O(1)       |      상수 |
   | O(log n)   |      로그 |
   | O(n)       | 1차, 선형 |
   | O(n log n) | 선형 로그 |
   | O(n^2)     |       2차 |
   | O(n^3)     |       3차 |
   | O(2^n)     |      지수 |
   | O(n!)      |      계승 |
- 위 최고차항은 n이 증가함에 따라 위 순서로 커진다.
- 위 순서를 참고해 가장 효율적인 알고리즘 선택이 가능
