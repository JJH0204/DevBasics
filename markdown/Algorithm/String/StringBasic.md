## strlen()

|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | size_t strlen(const char \*s);         |
| 기능   | s가 가리키는 문자열의 길이를 반환한다. |
| 반환값 | 구한 문자열의 길이 반환                |

## strchr()
|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | size_t strchr(const char \*s, int c);         |
| 기능   | s가 가리키는 문자열에서 가장 앞쪽에 있는 c를 찾는다.<br/>이때 c는 널 문자여도 가능 |
| 반환값 | 찾은 문자에 대한 포인터를 반환<br/>문자가 없으면 널 포인터 반환                |

## strrchr()
|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | size_t strrchr(const char \*s, int c);         |
| 기능   | s가 가리키는 문자열에서 가장 뒤쪽에 있는 c를 찾는다.<br/>이때 c는 널 문자여도 가능 |
| 반환값 | 찾은 문자에 대한 포인터를 반환<br/>문자가 없으면 널 포인터 반환                |

# 1. 문자열 비교
- C 언어는 두 문자열의 대소 관계를 판단하는 표준 라이브러리 함수로 strcmp 함수와 strncmp 함수를 제공한다.
## strcmp()
|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | size_t strcmp(const char \*s1, const char \*s2);         |
| 기능   | s1, s2가 가리키는 문자열의 대소 관계를 비교 <br/>처음부터 순서대로 한 문자씩 unsigned char형 값으로 비교 |
| 반환값 | 문자열이 값으면 0, s1이 s2보다 크면 양의 정수, 작으면 음의 정수 값 반환 |

## strncmp()
|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | size_t strncmp(const char \*s1, const char \*s2, size_t n);         |
| 기능   | s1, s2가 가리키는 문자 배열에서 n번째 문자까지 대소 관계를 비교<br/>처음부터 순서대로 한 문자씩 unsigned char형 값으로 비교<br/>널 문자 이후의 비교는 하지 않는다.|
| 반환값 | 문자열이 값으면 0, s1이 s2보다 크면 양의 정수, 작으면 음의 정수 값 반환 |

# 2. 브루트-포스법(brute force method)
- 문자열 검색이란, 어떤 문자열 안에 다른 문자열이 들어있는지 조사하고 들어있다면 그 위치를 찾아내는 것을 말한다.
- 원본 문자열을 텍스트(text), 검색할 문자열을 패턴(pattern)이라고 지칭한다.
- 브루트-포스법은 선형 검색을 확장한 알고리즘으로 단순법, 소박법이라고도 한다.
- 이 알고리즘의 시간 복잡도는 O(mn)이지만 일부러 꾸민 패턴이 아니라면 시간 복잡도는 O(n)으로 된다고 알려져 있습니다.
- 단순한 알고리즘이지만 실제는 아주 빠르게 동작합니다.

# 3. KMP법
- 브루트-포스법의 단점인 다음 텍스트를 찾기 위해 처음으로 돌아가는 비효율성을 개선한 알고리즘이다.
- 검사했던 위치 결과를 버리지 않고 효율적으로 활용한다.
- 텍스트와 패턴의 겹치는 부분을 찾아내어 검사를 다시 시작할 위치를 구한다.
- 몇 번째 문자부터 다시 검색할지 미리 표로 만들어 관리한다.
- 시간 복잡도는 가장 나쁜 경우에도 O(n)입니다.
- 다만 처리가 복잡하고 패턴 안에 반복 이 없으면 효율이 좋지 않습니다.
- 그러나 검색 과정에서 검사하는 위치를 앞으로 되돌릴 필요가 없다는 특징이 있어 순서 파일을 읽어 들이며 검색할 때 많이 사용합니다.

# 4. Boyer-Moore법
- 패턴의 마지막 문자부터 앞쪽으로 검사를 진행하면서 일치하지 않는 문자가 있으면 미리 준비한 표에 따라 패턴을 옮길 크기를 정한다.
- 시간복잡도는 가장 나쁜 경우라도 O(n)이고 평균적으로 O(n/m)입니다.
- 앞에서는 배 열을 1개만 사용하여 알고리즘을 구현했지만 2개의 배열을 사용하면 KMP법과 마찬가지로 배열을 만 드는 데 복잡한 처리가 필요하므로 효과가 떨어집니다.
- 1개의 배열을 사용하는 방법으로 간단하게 구 현한 Boyer-Moore법을 사용해도 충분히 빠릅니다.


# 5. strstr()
|        |                                        |
| :----- | :------------------------------------- |
| 헤더   | #include <string.h>                    |
| 형식   | char *strstr(const char \*s1, const char \*s2);         |
| 기능   | s1이 가리키는 문자열에서 s2가 가리키는 문자열과 일치하는(널 문자를 포함하지 않는) 문자열을 찾는다.<br/>가장 앞쪽에 나오는 문자열을 찾는다.|
| 반환값 | 찾아낸 문자열에 대한 포인터(첫 번째 문자에 대한 포인터)를 반환,<br/>찾지 못하면 널 포인터를 반환.<br/>s2가 길이가 0인 문자열이면 s1을 반환|