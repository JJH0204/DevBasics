# [Bubble Sorting] 버블 정렬 알고리즘
- 배열(또는 리스트)의 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복하는 알고리즘
- 마치 비눗방울과 비슷한 모양이라고 해서 지어진 이름
- (오름차순 정렬 기준) 배열의 끝 부터 차례로 이웃한 요소와 값을 비교하여 큰 값은 뒤로, 작은 값은 앞으로 이동시킨다.
- 배열 요소의 개수가 n개일 때 n - 1 회 비교, 교환 작업을 진행한다.
- 위 (비교 및 교환 작업)과정을 패스(pass)라고 하며 첫번째 패스에서는 가장 작은 값이 배열의 가장 처음으로 이동하게 된다.
- (패스 시작 지점이 배열의 끝이 아니라 시작 지점이라면 배열의 가장 큰 값이 배열의 끝으로 이동하게 된다.)
- 배열의 가장 작은 값(또는 가장 큰 값)을 정렬한 후 다음 정렬을 위헤 n - 2회 패스를 진행한다.
- 모든 정렬이 끝나려면 n - 1 회 패스가 진행되어야 한다. (n - 1개 요소의 정렬이 끝나면 마지막 요소는 이미 끝에 놓이기 때문)

# 소스 코드
```c
/* 버블 내부 교환 매크로 함수*/
#define swapBubble(type, x, y) \
    do                   \
    {                    \
        type t = x;      \
        x = y;           \
        y = t;           \
    } while (0)

/* 버블 정렬 */
void bubble(int *a, int n)
{
    int i, j;
    for (i = 0; i < n - 1; i++)
        for (j = n - 1; j > i; j--) /* 배열 끝 부터 패스 */
            if (a[j - 1] > a[j])
                swapBubble(int, a[j - 1], a[j]);
}
```
> TIP. 여러 줄에 걸쳐 매크로를 작성하고자 할 때는 \ (역슬래시)를 사용    

- 배열의 끝(오른쪽)부터 스캔하기 때문에 j의 시작값은 n - 1
- a[j - 1]과 a[j]를 비교해 앞쪽이 크면 교환
- j 값은 1씩 감소
- 한번의 패스에서 j의 값이 i + 1이 될 때까지 비교, 교환 수행
- 서로 이웃한 요소에 대한 비교, 교환이 이뤄짐으로 안정적이라 할 수 있다.
- 이동 횟수의 평균: $3n(n - 1) / 4$회