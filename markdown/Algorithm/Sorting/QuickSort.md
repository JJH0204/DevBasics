# 1. 퀵 정렬: Quick Sort

- 빠른 정렬 알고리즘 중 하나
- 배열을 구성하는 요소 중 임의의 요소를 선택
- 선택한 요소를 기준으로 값이 큰 그룹과 작은 그룹으로 나눈다.
- 그룹을 구성하는 요소가 1개가 될때까지 반복
- 기준으로 사용되는 선택된 요소는 피벗(pivot)이라 한다.

# 2. 배열을 두 그룹으로 나누기

## 2.1. [소스 코드](../../../source/DSNA/Sorting/includeSorting.c#L369)

## 2.2. 코드 리뷰

### 2.2.1. 실행 결과

```
<Before>
Index:  00      01      02      03      04      05      06      07      08      09
Array:  06      09      03      08      01      05      02      07      10      04
<After>
run "partition"
Index:  00      01      02      03      04      05      06      07      08      09
Array:  04      02      03      05      01      08      09      07      10      06

```

### 2.2.2. 분석

1. 초기 설정

```c
int pl = 0;       /* 좌측 커서 */
int pr = n - 1;   /* 우측 커서 */
int x = a[n / 2]; /* 피벗 설정 */
```

- 좌측 커서를 배열의 시작, 우측 커서를 배열의 끝으로 설정한다.
- 분류의 기준이 될 피벗을 배열 요소 개수 / 2 인덱스로 설정한다.
  `pl = 0, pr = 9, x = a[5] = 5`

2. 좌측 그룹에서 피벗 보다 크거나 같은 값 찾기

```c
while (a[pl] < x)
    pl++;
```

```
Index:  [00]      01      02      03      04       05       06      07      08      09
Array:  [06]      09      03      08      01      <05>      02      07      10      04
```

3. 우측 그룹에서 피벗 보다 작거나 같은 값 찾기

```c
while (a[pr] > x)
    pr--;
```

```
Index:  [00]      01      02      03      04       05       06      07      08      [09]
Array:  [06]      09      03      08      01      <05>      02      07      10      [04]
```

4. 찾은 두 값을 교환

```c
swap(int, a[pl], a[pr]);
pl++;
pr--;
```

```
Index:  [00]      01      02      03      04       05       06      07      08      [09]
Array:  [04]      09      03      08      01      <05>      02      07      10      [06]
```

5. 위 과정을 pl > pr 가 성립될 때까지 반복

```c
while (pl <= pr)
{
    /* code */
    if (pl <= pr)
    {
        /* code */
    }
}
```

```
(2 회차)
Index:  00      [01]      02      03      04       05       [06]      07      08      09
Array:  04      [09]      03      08      01      <05>      [02]      07      10      06
실행 후
Index:  00      [01]      02      03      04       05       [06]      07      08      09
Array:  04      [02]      03      08      01      <05>      [09]      07      10      06
```

```
(3 회차)
Index:  00      01      02      [03]      04       [05]       06      07      08      09
Array:  04      02      03      [08]      01      <[05]>      09      07      10      06
실행 후
Index:  00      01      02       [03]       04      [05]      06      07      08      09
Array:  04      02      03      <[05]>      01      [08]      09      07      10      06
```

- 4 회차 반복에서 종료 조건을 충족해 프로그램 종료
- 피벗을 포함한 그룹과 그렇지 않은 그룹으로 분리되었다.

# 3. 퀵 정렬 구현

- "2. 배열 나누기"를 아이디어를 응용해 퀵 정렬을 구현할 수 있다.
- 피벗과 비교할 왼쪽, 오른쪽 요소를 가리키는 두 변수 pl, pr을 활용해 배열을 분할하여 정렬할 수 있다.
- 이진 탐색 트리의 아이디어 처럼 분할 정복을 위한 재귀함수로 구현도 가능하다.

## 3.1. 재귀함수로 구현한 퀵 정렬

- [소스코드](../../../source/DSNA/Sorting/includeSorting.c#L398)
- 배열 나누기 소스 코드와 동일하지만 이후 재귀함수 형식으로 분할정복을 진행하는 것에서 차이가 있다.
- 기존의 사용방법 void (*Sorting)(int *a, int n)방식으로 호출할 수 있도록 수정해 보자

## 3.2. 반복문으로 구현한 퀵 정렬

- [소스코드](../../../source/DSNA/Sorting/includeSorting.c#L456)

## 3.3. 알고리즘 개선 1

- 배열 요소를 분할하여 정렬하는 것이 메인 아이디어인 퀵 정렬의 단점은 정렬할 요소의 수가 적을 때 효율이 떨어진다는 점인다.
- 이를 개선하여 분할한 배열의 요소가 9개 미만인 경우 "단순 삽입 정렬"을 수행하도록 알고리즘을 개선한다.
- 위 방식을 **하이브리드 정렬** 이라고 한다.
- [소스코드](../../../source/DSNA/Sorting/includeSorting.c#L518)

## 3.4. 알고리즘 개선 2

- 퀵 정렬을 위한 피벗 선택은 매우 중요한 과정이다.
- 선택한 피벗에 따라 최악의 상황에는 $O(n^2)$의 시간 복잡도를 갖기 때문이다.
- 아래는 퀵 정렬에 적합한 피벗 선택 방법 두 가지를 적용한 예시 코드다.
  1. 피벗 선택 전 임의의 값 3개(배열의 시작, 끝, 중앙)를 골라 그중 중앙값인 요소를 피벗으로 설정
     - 피벗을 포함한 값 비교가 진행되는 점에서 비효율적이다.
  2. 1번의 방법을 수행한 후 가운대 요소와 끝에서 -1 요소의 값을 교환.
     - 피벗으로 배열의 끝에서 두 번째(right -2)값을 선택해 배열을 나눌 범위를 (left + 1)~(right - 2)로 좁힌다.
     - 피벗을 제외한 후 배열의 탐색 범위가 줄어 보다 효율적인 탐색이 가능하다.
- [소스코드](../../../source/DSNA/Sorting/includeSorting.c#L595)

# 4. qsort()

- 헤더: `#include <stdlib.h>`
- 함수 원형: `void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void * const void *));`
- 인자 값 설명:
  |변수명|설명|
  |:--|:--|
  |void *base|정렬할 배열의 시작 주소를 가리킨다.|
  size_t nmemb|배열을 구성하는 요소의 개수|
  size_t size|배열을 구성하는 요소가 메모리에 할당된 최소 크기|
  int(*compar)(const void *, const void *)|compar로 지정한 비교 함수를 사용해 정렬 수행<br/>비교 함수는 다음과 같은 기능을 할 수 있도록 직접 작성해야 합니다.<br/> 1. 첫 번째 인수가 두 번째 인수보다 작은 경우에는 0보다 작 은 값을<br/> 2. 같을 경우에는 0을<br/> 3. 클 경우에는 0보다 큰 정수를 반환합니다.<br/>TIP. 비교하는 두 요소가 같을 경우에는 순서를 다시 배치하지 않습니다.|
- 특징:
  - bsearch()와 마찬가지로 int형이나 double형 등의 배열 뿐만 아니라 구조체 배열 등 모든 자료형의 배열에 적용 가능
  - 함수 이름은 퀵 정렬에서 따왔지만 내부적으로 항상 퀵정렬만 수행하지 않음
- [소스 코드](../../../source/DSNA/Sorting/includeSorting.c#L759)