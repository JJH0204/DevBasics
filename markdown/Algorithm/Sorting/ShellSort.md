# 셸 정렬: Shell Sort
## 1. 단순 정렬의 장단점
- 장점: 배열이 정렬된 상태에 가깝거나 정렬을 마쳤을 때 정렬 속도가 매우 빠르다.
- 단점: 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.

## 2. 셸 정렬의 특징
- 단순 정렬 알고리즘의 장점은 유지하고 단점을 개선한 정렬 알고리즘
- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹 별로 단순 삽입 정렬을 수행 > 그룹을 합치며 정렬을 반복
- 요소의 이동 횟수를 줄이는 방법
- 셸 정렬의 시간 복잡도는 $O(n^1.23)$으로 기존의 $O(n^2)$에 비해 매우 빠른 속도를 보인다.
- 멀리 떨어진 요소를 교환함으로 안정적이지 않는다.

## 3. 셸 정렬 과정
### 3.1. 정렬 전 상태
```
<Before> 
Index:  00      01      02      03      04      05      06      07      08      09
Array:  05      08      04      07      01      06      09      03      10      02
```
### 3.2. 5 그룹으로 나눠서 정렬
- 2개의 요소에 대해 '5-정렬'을 수행 후 병합
- arraySize / 비교하는 요소 수 > "h - 정렬"이라 부른다. ( 이번에는 "5 - 정렬")
```
(1) 
Index:  [00]      01      02      03      04      [05]      06      07      08      09
Array:  [05]      08      04      07      01      [06]      09      03      10      02

(2) 
Index:  00      [01]      02      03      04      05      [06]      07      08      09
Array:  05      [08]      04      07      01      06      [09]      03      10      02

(3) 
Index:  00      01      [02]      03      04      05      06      [07]      08      09
Array:  05      08      [04]      07      01      06      09      [03]      10      02
정렬 후
Index:  00      01      [02]      03      04      05      06      [07]      08      09
Array:  05      08      [03]      07      01      06      09      [04]      10      02

(4) 
Index:  00      01      02      [03]      04      05      06      07      [08]      09
Array:  05      08      04      [07]      01      06      09      03      [10]      02

(5) 
Index:  00      01      02      03      [04]      05      06      07      08      [09]
Array:  05      08      04      07      [01]      06      09      03      10      [02]
```
```
5-정렬 후 병합
Index:  00      01      02      03      04      05      06      07      08      09
Array:  05      08      03      07      01      06      09      04      10      02
```

### 3.3. 5 / 2 그룹으로 나눠서 정렬
- 5개 요소에 대해 '2-정렬' 수행 후 병합
```
(1)
Index:  [00]      01      [02]      03      [04]      05      [06]      07      [08]      09
Array:  [05]      08      [03]      07      [01]      06      [09]      04      [10]      02
정렬 후
Index:  [00]      01      [02]      03      [04]      05      [06]      07      [08]      09
Array:  [01]      08      [03]      07      [05]      06      [09]      04      [10]      02

(2)
Index:  00      [01]      02      [03]      04      [05]      06      [07]      08      [09]
Array:  05      [08]      03      [07]      01      [06]      09      [04]      10      [02]
정렬 후
Index:  00      [01]      02      [03]      04      [05]      06      [07]      08      [09]
Array:  05      [02]      03      [04]      01      [06]      09      [07]      10      [08]
```
```
2-정렬 후 병합
Index:  00      01      02      03      04      05      06      07      08      09
Array:  01      02      03      04      05      06      09      07      10      08
```

### 3.4. 단순 삽입 정렬 진행
- 10개 요소에 대해 '1-정렬' (단순 삽입 정렬) 수행
```
(1)
Index:  [00]      [01]      [02]      [03]      [04]      [05]      [06]      [07]      [08]      [09]
Array:  [01]      [02]      [03]      [04]      [05]      [06]      [09]      [07]      [10]      [08]
정렬 후
Index:  [00]      [01]      [02]      [03]      [04]      [05]      [06]      [07]      [08]      [09]
Array:  [01]      [02]      [03]      [04]      [05]      [06]      [07]      [08]      [09]      [10]
```

## 4. [소스 코드](../../../source/DSNA/Sorting/includeSorting.c#L342)

## 5. 알고리즘 개선 1
- 증분값(h)을 선택하는 과정에서 h값이 서로 배수가 되지 않도록 해야한다.
```
(a)
8, 1, 4, 2, 7, 6, 3, 5

(b)
8, 7
1, 6
4, 3
2, 5

(c)
7, 3, 8, 4
1, 2, 6, 5
```
- 위 예제를 보아 배열 요소를 그룹으로 나눠도 a를 구성하는 c의 정렬 상태는 그룹으로 나누기 전과 다름이 없다.
