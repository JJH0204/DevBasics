# 1. 해시법
- 검색과 더불어 데이터 추가와 삭제도 효율적으로 수행할 수 있는 방법
- 기존에 정렬된 배열에서 데이터 추가를 위해 삽입할 위치를 조사하고, 추가한 위치 이후의 데이터를 하나씩 뒤로 이동시키는 작업이 필요했다.
- 데이터 이동에 시간 복잡도 $O(n)$이 소요되는데 이는 적은 시간이 아니다. (데이터 삭제에도 동일)
- 해시법(hashing)은 데이터를 저장할 위치(인덱스)를 간단한 연산으로 구하는 것을 의미하며, 검색뿐만 아니라 추가, 삭제에도 효율적으로 수행할 수 있게 해준다.

## 1.1. 표현 정리
array : { 5, 6, 14, 20, 29, 34, 37, 51, 69, 75}
해시 값(hash value): { 5, 6, 1, 7, 3, 8, 11, 12, 4, 10}
해시 테이블: { , 14, , 29, 69, 5, 6, 20, 34, , 75, 37, 51}
- 배열의 각 요소를 배열의 요소 개수(13)으로 나눠서 표에 정리한 값을 "해시 값"이라 한다.
- 해시 값이 인덱스가 되도록 원래 키 값을 저장한 배열을 해시 테이블(hash table)이라 한다.

- '35'를 추가하는 상황에서도 35 % 13 = 9를 인덱스로 헤시 테이블에 저장 한다.
해시 테이블: { , 14, , 29, 69, 5, 6, 20, 34, "35", 75, 37, 51}
- 이렇게 해시 값을 만드는 과정을 해시 함수(hash function)이라고 한다.
- 해시 테이블의 각 요소를 버킷(bucket)이라 한다.

# 2. 충돌
- 아래 배열에 새로운 값 18을 추가하는 경우를 가정했다.
{ , 14, , 29, 69, 5, 6, 20, 34, 35, 75, 37, 51}
                  ㄴ 18 , 이미 채워진 상태
- 키 값과 해시 값의 대응 관계가 반드시 1대1 이라는 보증이 없다. (n 대 1 관계)
- 저장할 버킷이 중복되는 현상을 충돌(collision)이라고 한다.
- 해시 함수는 가능하면 해시 값이 중복되지 않도록 고르게 분포된 값을 만들어야 한다.

## 2.1. 충돌 대처 방안
1. 체인법 : 같은 해시 값을 갖는 요소를 연결 리스트로 관리
2. 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복

## 2.2. 키 값과 데이터
- 해시법을 사용하는 프로그램에서 다루는 데이터는 단순한 정수나 실수가 아니라 여러 데이 터가 결합된 '구조체'인 경우가 많다.
- 회원 번호(간단히 '번호'라고 표현)와 이름만으로 구성된 스포츠 클럽의 회원을 생각해 보겠습니다.
- [소스코드](../../source/Algorithm/Hashing/includeMember.c)
- [헤더파일](../../include/includeMember.h)

## 2.3. 체인법(chaining)
- 같은 해시 값을 갖는 데이터을 쇠사슬(chain)모양으로 연결 리스트로 연결하는 방법
- 오픈 해시법(open hashing)이라고도 함
- 해시 테이블의 각 버킷에 저장하는 값은 그 인덱스를 해시 값으로 하는 연결 리스트의 첫 번째 노드에 대한 포인터이다.

## 2.3.1. 해시와 해시 함수
- 충돌이 전혀 발생하지 않는다 가정하면 검색, 추가, 삭제 작업은 인덱스 찾기로 해결된다.
- 시간 복잡도는 $O(1)$, 데이터 추가 시 해시 테이블을 크게 만들면 충돌 발생을 억제할 수 있지만 쓸데없이 많은 메모리를 사용하게 된다.
- 시간과 공간의 절충(trade-off) 문제가 발생
- 충돌을 피하기 위해 해시 함수는 해시 테이블 크기 이하의 정수를 가능한 치우치지 않고 고르게 만들어야 한다.
- 해시 테이블의 크기는 소수(1 또는 자기자신으로 만 나눠지는 정수)가 좋다고 한다.
- 키 값이 정수가 아닌 경우 해시 값을 구하려면 다른 방법을 사용해야 한다.
- 실수 키 값에 대한 비트 연산, 문자열 키 값에 대한 문자 코드에 곱셈, 덧셈을 하는 방법 등 있다.

## 2.3.2. 실행 예시
```sh
1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 1
추가, Please enter the data.
No: 1
Name: 붉은꼬리
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 1
추가, Please enter the data.
No: 5
Name: 박현규
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 1
추가, Please enter the data.
No: 10
Name: 제니
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 1
추가, Please enter the data.
No: 12
Name: 영준
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 1
추가, Please enter the data.
No: 14
Name: 윤미
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 3
검색, Please enter the data.
No: 5
검색에 성공했습니다.: 5 박현규
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 5
00
01 -> 14 :(윤미) -> 1 :(붉은꼬리)
02
03
04
05 -> 5 :(박현규)
06
07
08
09
10 -> 10 :(제니)
11
12 -> 12 :(영준)
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 2
삭제, Please enter the data.
No: 14
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 5
00
01 -> 1 :(붉은꼬리)
02
03
04
05 -> 5 :(박현규)
06
07
08
09
10 -> 10 :(제니)
11
12 -> 12 :(영준)
(1)추가 (2)삭제 (3)검색 (4)모두 삭제 (5)덤프 (0)종료 : 0
```

## 2.4. 오픈 주소법(Open addressing)
- 충돌이 발생했을 때 재해시(rehashing)를 수행, 비어 있는 버킷을 찾아내는 방법
- 닫힌 해시법(Closed hashing)이라고도 한다.
- 빈 버킷을 만날 때까지 재해시를 여러 번 반복함으로 연결 탐사법(linear probing)이라고도 한다.
### 2.4.1. 삽입
1. { , 14, , 29, , 5, 6, , 34, , 75, 37, 51} <- 18 추가 시도, 해시 값 5(충돌 발생)
2. { , 14, , 29, , 5, 6, , 34, , 75, 37, 51} <- 18 + 1 추가 시도, 해시 값 6(충돌 발생)
3. { , 14, , 29, , 5, 6, 18, 34, , 75, 37, 51} <- 19 + 1 추가 시도, 해시 값 7 (삽입)

### 2.4.2. 삭제
1. { , 14, , 29, , 5, 6, 18, 34, , 75, 37, 51} <- 5 삭제 시도, 같은 해시 값 18로 인해 추가 연산 필요
2. { , 14, , 29, , @, 6, 18, 34, , 75, 37, 51} <- 별도 설정값을 저장해 다른 버킷에 동일한 해시 값의 데이터가 저장되어 있음을 알린다.

### 2.4.3. 검색
1. { , 14, , 29, , @, 6, 18, 34, , 75, 37, 51} <- 18 검색, 해시 5의 버킷에 데이터 삭제를 나타내는 속성값이 저장되어 있음
2. { , 14, , 29, , @, 6, 18, 34, , 75, 37, 51} <- 18 검색, 해시 6에 6이 저장되어 있음
3. { , 14, , 29, , @, 6, 18, 34, , 75, 37, 51} <- 18 검색, 해시 7에 18을 찾았다.